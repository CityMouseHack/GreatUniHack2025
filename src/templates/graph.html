<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Visualization</title>
    <style>
        body { background-color: #111; color: #fff; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; margin: 0; font-family: Arial, sans-serif; }
        canvas { background-color: #000; border: 1px solid #444; cursor: pointer; }
        p { margin-top: 20px; }
    </style>
</head>
<body>

    <canvas id="visualizationCanvas" width="800" height="600"></canvas>
    <p>Click on the canvas to regenerate the layout.</p>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- 1. SETUP ---
            const canvas = document.getElementById('visualizationCanvas');
            const ctx = canvas.getContext('2d');

            // --- 2. DATA LOADING ---
            let data;
            try { data = JSON.parse('{{ chart_data|safe }}'); } 
            catch (e) {
                console.error("Failed to parse data from Flask:", e);
                ctx.fillStyle = 'red'; ctx.font = '20px Arial'; ctx.textAlign = 'center';
                ctx.fillText('Error: Could not load data.', canvas.width / 2, canvas.height / 2);
                return;
            }

            // --- 3. CONFIGURATION ---
            const pointRadius = 25;
            const solidLineThreshold = 350;
            const dottedLineThreshold = 500;
            const minimumNodeDistance = 150;
            const maxPlacementAttempts = 100;
            const numberOfTextureDots = 50;
            const numberOfStars = 300;
            const starColors = ['#FFFFFF', '#FFFFE0', '#ADD8E6', '#FFFAF0'];

            // ***** NEW CONFIGURATION for MOONS *****
            const maxMoonsPerPlanet = 4; // Maximum number of moons a planet can have.
            const moonColors = ['#E5E4E2', '#C0C0C0', '#A9A9A9']; // Platinum, Silver, DarkGray

            let points = [];
            let stars = [];

            // --- 4. FUNCTIONS ---

            function generateStars() { /* ... function unchanged ... */ 
                for (let i = 0; i < numberOfStars; i++) {
                    stars.push({
                        x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                        radius: Math.random() * 1.5,
                        color: starColors[Math.floor(Math.random() * starColors.length)]
                    });
                }
            }

            function drawStars() { /* ... function unchanged ... */ 
                ctx.save();
                stars.forEach(star => {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    ctx.fillStyle = star.color;
                    ctx.fill();
                });
                ctx.restore();
            }

            function getDistance(point1, point2) { /* ... function unchanged ... */ 
                const dx = point1.x - point2.x;
                const dy = point1.y - point2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // ***** MODIFIED FUNCTION: generatePointPositions() *****
            // It now also generates the moons for each planet.
            function generatePointPositions() {
                points = [];
                data.forEach(item => {
                    let newPoint;
                    let isValidPosition = false;
                    let attempts = 0;
                    while (!isValidPosition && attempts < maxPlacementAttempts) {
                        newPoint = {
                            name: item.name, color: item.color,
                            x: pointRadius + Math.random() * (canvas.width - pointRadius * 2),
                            y: pointRadius + Math.random() * (canvas.height - pointRadius * 2),
                            moons: [] // Each point now has an array for its moons
                        };
                        isValidPosition = true;
                        for (const existingPoint of points) {
                            if (getDistance(newPoint, existingPoint) < minimumNodeDistance) {
                                isValidPosition = false; break;
                            }
                        }
                        attempts++;
                    }
                    
                    // After placing a planet, generate its moons
                    const moonCount = Math.floor(Math.random() * (maxMoonsPerPlanet + 1));
                    for (let i = 0; i < moonCount; i++) {
                        newPoint.moons.push({
                            orbitRadius: pointRadius + 10 + Math.random() * 20, // Distance from planet
                            angle: Math.random() * Math.PI * 2, // Starting position in orbit
                            speed: (Math.random() - 0.5) * 0.02, // Random speed and direction
                            radius: Math.random() * 2 + 1, // Moon size
                            color: moonColors[Math.floor(Math.random() * moonColors.length)]
                        });
                    }
                    points.push(newPoint);
                });
            }

            function drawConnections() { /* ... function unchanged ... */ 
                for (let i = 0; i < points.length; i++) {
                    for (let j = i + 1; j < points.length; j++) {
                        const distance = getDistance(points[i], points[j]);
                        ctx.lineWidth = 1.5; ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                        if (distance < solidLineThreshold) {
                            ctx.beginPath(); ctx.setLineDash([]);
                            ctx.moveTo(points[i].x, points[i].y); ctx.lineTo(points[j].x, points[j].y);
                            ctx.stroke();
                        } else if (distance < dottedLineThreshold) {
                            ctx.beginPath(); ctx.setLineDash([5, 10]);
                            ctx.moveTo(points[i].x, points[i].y); ctx.lineTo(points[j].x, points[j].y);
                            ctx.stroke();
                        }
                    }
                }
            }
            
            function drawPoints() { /* ... function unchanged ... */ 
                points.forEach(point => {
                    const gradient = ctx.createRadialGradient(point.x - pointRadius * 0.3, point.y - pointRadius * 0.3, pointRadius * 0.1, point.x, point.y, pointRadius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)'); gradient.addColorStop(0.8, point.color); gradient.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
                    ctx.beginPath(); ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient; ctx.fill();
                    for (let i = 0; i < numberOfTextureDots; i++) {
                        const angle = Math.random() * Math.PI * 2; const radius = Math.random() * pointRadius;
                        const x = point.x + Math.cos(angle) * radius; const y = point.y + Math.sin(angle) * radius;
                        ctx.beginPath(); ctx.arc(x, y, Math.random() * 2, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; ctx.fill();
                    }
                    ctx.fillStyle = '#fff'; ctx.font = '16px Arial'; ctx.textAlign = 'center';
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 5;
                    ctx.fillText(point.name, point.x, point.y - pointRadius - 12);
                    ctx.shadowBlur = 0;
                });
            }

            // ***** NEW FUNCTION: drawMoons() *****
            // Updates moon positions and draws them.
            function drawMoons() {
                points.forEach(point => {
                    point.moons.forEach(moon => {
                        // Update the angle to make it orbit
                        moon.angle += moon.speed;

                        // Calculate the moon's x and y position using trigonometry
                        const moonX = point.x + moon.orbitRadius * Math.cos(moon.angle);
                        const moonY = point.y + moon.orbitRadius * Math.sin(moon.angle);

                        // Draw the moon
                        ctx.beginPath();
                        ctx.arc(moonX, moonY, moon.radius, 0, Math.PI * 2);
                        ctx.fillStyle = moon.color;
                        ctx.fill();
                    });
                });
            }


            // --- 5. ANIMATION LOOP ---
            
            // ***** NEW FUNCTION: animate() *****
            // This is the main animation loop that runs on every frame.
            function animate() {
                // Step 1: Clear the entire canvas for the new frame
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Step 2: Draw the static background
                drawStars();

                // Step 3: Draw the planet-to-planet connections
                drawConnections();
                
                // Step 4: Draw the planets themselves
                drawPoints();

                // Step 5: Update moon positions and draw them on top
                drawMoons();

                // Step 6: Request the next frame to continue the loop
                requestAnimationFrame(animate);
            }

            
            // --- 6. INITIALIZATION ---
            generateStars(); // Generate the starfield ONCE
            generatePointPositions(); // Generate the initial planet layout and their moons
            
            animate(); // Start the animation loop!

            // When the canvas is clicked, just regenerate the planet layout.
            // The animation loop will automatically pick up the new positions.
            canvas.addEventListener('click', generatePointPositions);
        });
    </script>
</body>
</html>